#summary Explain XML instruction file.

<font color="red">THIS PAGE IS UNDER CONSTRUCTION</font>

<wiki:toc max_depth="8" />

= Introduction =

This page explains the contents of the XML instruction file.


= getContentItemList =

This is the root element in the instruction file.

*Attributes*
 * none

*Occurrence*
 since it is the root element, one and only one

*Allowed Children*
 * mandatory Children
   * getContentItem (1, 2, ...)
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
...
</getContentItemList>
}}}

== getContentItem ==

A getContentItem defines how and where to get the contents for one specific goal.
The XML element has one attribute called "id".
For example the goal could be to get the list of news titles. The requesting application needs to know the "id" to use to find the corresponding instructions.

Another example could be to fetch a TV guide. Typically a TV guide will consist of several columns, like "Program", "Channel", "Time", .. In such a case there would be three getContentItem's, each with another "id". To avoid having to get the same source (which is typicall an HTML or XML page downloaded over the internet), in such case there would be one first getContentItem whose goal is simply to download the complete page and to store in a String object. Then the next three getContentItem's would use that String as input and get a list of Programs, Channels and Time's; that means also that the source can also be a string supplied by the application.

*Attributes*
 * mandatory attributes
   * id
     A free format text used by the application to define the getContentItem to use.

*Occurrence*
 A getContentItemList must have at least one getContentItem

*Allowed Children*
 * mandatory Children
   * description (1)
   * instructionList (1)
 * optional Children
   * url : 0, 1 or more. If there's 1 or more url, then the first url must be reachable.
   * any element for which a class exists with the same name and derived from the class CustomObject. In this case, the GetContents object must be created with the constructor that takes a package name as argument, being the name of the package where this new class is defined.

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
...
   </getContentItem>
   <getContentItem id="another free format text"> 
...
   </getContentItem>
...
</getContentItemList>
}}}

=== description ===

This is free format description. Not really used yet.

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <description>
          Android World forum
      </description>
...
   </getContentItem>
...
</getContentItemList>
}}}

=== url ===

The url where the source needs to be downloaded.<br>
Can also be a local file.<br>
Format for a remote url : http://...<br>
Format for a local file : file://localhost/....<br>

Is optional, in case not present, then application must start the instructionList with source parameter which can again be a url (anything starting with '<') or the actual source content (anything not starting with '<').

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none

*Example*

a remote url
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <url>
          http://www.androidworld.nl/forum/external.php
      </url>
...
   </getContentItem>
...
</getContentItemList>
}}}


a local file
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <url>
          file://localhost/Users/Johan/temp/test.html
      </url>
...
   </getContentItem>
...
</getContentItemList>
}}}


=== instructionList ===

List of instructions to be executed on the source.
Instructions take as input an array of strings.<br>
An htmlFilter, htmlGetter, XMLFilter and XMLGetter can take a string
or a url (remote or local file) as input. <br>
Also the instruction getUnFilteredContent takes as input a url.<br>

There can be consecuive XMLFilter and XMLGetter, however if the last instruction in an XMLGetter is the instruction "text", then it's not allowed to have it followed by additional XMLFilter or XMLGetter instructions.

*Attributes*
 * none

*Occurrence*
 at least 1

*Allowed Children*
 at least one off :
 * addXMLDeclaration
 * getUnFilteredContent
 * htmlFilter
 * htmlGetter
 * processString
 * XMLFilter
 * XMLGetter

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 

...
   one or more instructions
...
   </getContentItem>
...
</getContentItemList>
}}}

==== addXMLDeclaration ====

Instruction to add an XML declaration on top of the input.<br>
This is not really needed anymore, if not needed will be deleted.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory Children
   * version
   * encoding

*Example*


==== getUnFilteredContent ====

If the input is a URL (anything not starting with '<'), it will fetch the content.
If the input is not a URL, it returns the input.<br>
So it is important, if the input is to be seen as a source text (ie not a URL), then the first non blank character should be a '<'.<br>re

If the source is a url, an InputStreamReader is created with the url and the encoding as parameter (encoding is an optional child). An array will be returned with one element that has the retrieved content.<br>
If the source is not a url, then the source is returned.<br>

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 *encoding, at most 1,  optional, default value the default characterset for the platform
 *requestProperty, 0, 1 or more, optional, in case http headers need to be added

===== encoding =====

defines the encoding to be used for opening the url('s)

===== requestProperty =====

defines a header key and value<br>
the getUnfilteredContent instruction will use URLConnection.setRequestProperty(String key, String value)<br>

====== key ======

key of the request parameter


====== value ======

value of the request parameter


==== htmlFilter ====

An htmlFilter instruction can have an unlimited number of html filters. For filtering, the package <a href="http://htmlparser.sourceforge.net/">HTML Parser</a> is used.

The input to the htmlFilter instruction doesn't need to be a full HTML page that includes a body, head tag and so on. So you could have the output of one htmlFilter instruction, use that as input for example to a processString instruction, and use the output of that instruction again as input for a new htmlFilter instruction.

The output of an htmlFilter will be an array of strings, where each string is the result of applying toHTML on each Node (as defined in the HTML Parser package).<br>
This output can then be used again as input to either another instruction like htmlFilter, htmlGetter, processString (it is unlikely that the output of an htmlFilter will be the  input to an XMLFilter or XMLGetter).

*Attributes*
 * recursive, optional
   Values : true or false.<br>
   If a first level node does not match a filter, and if recursive is true, then the filter will continue searching in the second level node and so on.
 * charset, optional
   values : for instance "ISO-8859-1" or "UTF-8"<br>
   Even if it is not always necessary to specify the charset to be used, because mostly it is available in the HTML page in a META TAG, it is safer to specify it.
 * unknowntag : a list of tags not known by default by the HTML Parser, tags are separated by space. For example a site uses "small" as tag. This tag is not known to the HTML Parser so will not create decent child list. By adding the attribute tag="small", the parser will consider the element small as a decent TagNode.
List can be longer eg "small script noscript"

*Occurrence*
 not defined

*Allowed Children*
 At least one child of the following list :
 * and
 * children
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter
 * tagName

===== and =====

An AndFilter has at least two other html filters as child.<br>
Nodes that match every filer match the and filter.


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 At least two other html filters :
 * and
 * children
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter
 * tagName

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" and an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true" charset="utf-8">
            <and>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
            </and> 
         </htmlFilter>
...
</getContentItemList>
}}}

===== children =====

will get the children if any

*Attributes*
none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*Example*<br>

===== cssSelectorNode =====

a CssSelectorNodeFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
none
*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the Selector

*Example*<br>


===== hasAttribute =====

checks for presence of a specified attribute, optionally with specified value.<br>
In case you want to filter on tags not known to the HTML Parser, then you must add a "tag" attribute to the first htmlFilter or htmlGetter preceding this htmlFilter.


*Attributes*
 *type determines if the value (if present) should be considered 'equals' or 'startswith'. Hence the possible values are 'equals' and 'startswith'.<br>
Default value is 'startswith'.

*Occurrence*
 none

*Allowed Children*
 * attributename
 * attributevalue

*text field*
 none

*Example*<br>
In this example we filter on nodes that have an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasChild =====

a HasChildFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

Filters on nodes that have a child that matches another included filter

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a child node that has an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
           <hasChild>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
           </hasChild>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasParent =====

a HasParentFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

Filters on nodes that have a parent node that matches another included filter

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a parent node that has an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
           <hasParent>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
           </hasParent>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasSibling =====

a HasSiblingFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none


===== linkRegexFilter =====

a LinkRegexFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   pattern

*text field*
 none

====== pattern ======

a pattern being a string and a case_sensitive attribute.
The pattern needs to compile with 
Pattern.compile(pattern,  case_sensitive == true ? 0: Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE));

*Attributes*
 case_sensitive true or false, default value = true

*Occurrence*
 1

*Allowed Children*
 none

*text field*
 the pattern string, untrimmed


===== linkStringFilter =====

a LinkStringFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 case_sensitive, value "true" or "false"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the pattern is defined by the textfield. The text field is stored untrimmed, that means for example inclusive carriage returns, ...


===== not =====

a NotFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 any HTML filter, only one

*text field*
 none

*example*
Filters nodes that do not have text matching the regular expression
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
            <not>
		<regexFilter>([01][0-9]|2[0-3]):[0-5][0-9]</regexFilter>
             </not>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== or =====

an OrFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 any HTML filter, at least two

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" or an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
            <or>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
            </or> 
         </htmlFilter>
...
</getContentItemList>
}}}

===== regexFilter =====

a RegexFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 strategy : possible values are "find", "lookingat" or "match"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the pattern, untrimmed

*Example*<br>
In this example we filter on nodes that have text with a time in the format HH:mm
{{{
<getContentItemList>
...
        <htmlFilter recursive="true">
            <regexFilter>([01][0-9]|2[0-3]):[0-5][0-9]</regexFilter>
         </htmlFilter>
...
</getContentItemList>
}}} 


===== stringFilter =====

a StringFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>
This is a fairly simplistic filter, so for more sophisticated string matching, for example newline and whitespace handling, use a regexFilter instead.


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory children
   pattern

*text field*
 none

====== pattern ======

Basically a string with one attribute named "case_sensitive" with value "true" or "false"<br>
The pattern needs to compile with 
Pattern.compile(pattern,  case_sensitive == true ? 0: Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE));<br>
Untrimmed.

*Attributes*
 "case_sensitive" with value "true" or "false", default value = true

*Occurrence*
 1

*Allowed Children*
 none

*text field*
 the pattern, untrimmed


===== tagName =====

a TagNameFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

In case you want to filter on tags not known to the HTML Parser, then you must add a "tag" attribute to the first htmlFilter or htmlGetter preceding this htmlFilter.


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the tag name

*Example*<br>
In this example we filter on nodes that have a tagname "DIV"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
               <tagName>
                  DIV
               </tagName>
         </htmlFilter>
...
</getContentItemList>
}}}


==== htmlGetter ====

gets from html nodes.


*Attributes*
 * recursive, optional,  with value true or false. If recursive and if one specific node returns no NodeList then dig deeper into that node
 * charset, optional
   values : for instance "ISO-8859-1" or "UTF-8"<br>
   Even if it is not always necessary to specify the charset to be used, because mostly it is available in the HTML page in a META TAG, it is safer to specify it.
 * unknowntag : a list of tags not known by default by the HTML Parser, tags are separated by space. For example a site uses "small" as tag. This tag is not known to the HTML Parser so will not create decent child list. By adding the attribute tag="small", the parser will consider the element small as a decent TagNode.
List can be longer eg "small script noscript"



*Occurrence*
 not defined

*Allowed Children*
 One ore more of following HTMLGetter :
 * attributeValue
 * children
 * removeNodes
 * tagName
 * text

*text field*
 none

===== attributeValue =====

allows to get the value of a specific attribute<br>
Will work on each first level node<br> 
If a node does not have an attribute with the specified name, then an empty string is returned

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the attributename

*example*

===== children =====

will get the children nodes of each node

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*example*
Let's assume we have following HTML as input, stored in /Users/Johan/temp/temp.txt

{{{
<TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

Now we run following instruction file :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example htmlGetter - children]]>
      </description>
      <instructionList>
         <htmlGetter>
            <children>
            </children>
         </htmlGetter>   
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is 

{{{
<TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
}}}


we can go one step further with the instructin file :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de zenders op]]>
      </description>
      <instructionList>
         <htmlGetter>
            <children>
            </children>
            <children>
            </children>
         </htmlGetter>   
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

now the result is (I must admit that I removed a lot of blank lines, I'm sure there will be other instructions to remove the blank lines like String Processors : 
{{{
<TD width="40%"><strong>Item</strong></TD>
<TD width="10%"><strong>Hoeveel</strong></TD>   
<TD width="10%"><strong>Eenheid</strong></TD>   
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>   
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>   
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>   
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}
  
===== removeNodes =====

Two criteria can be defined to remove a node :<br>
- all nodes matching the specified tag<br>
- all nodes having an attribute with the specified name and optionally with the specified value (case insensitive)<br>

both can be defined within one single removeNodes element<br>
- tag : just a a tag as text in the removeNodes element<br>
- attribute : add a child attributename and optionally a child attributevalue in the removeNodes element.<br>

*Attributes*
 recursive, if true will search till the end, otherwise false

*Occurrence*
 not defined

*Allowed Children*
 * attributename (optional)
 * attributevalue (optional but may not occur if there's no attributename child)

*text field*
 the tagname

*example*

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         ...
      </url>
...
      <instructionList>
         <htmlGetter recursive="false">
            <removeNodes recursive="true">script</removeNodes>
         </htmlGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>  
}}}

===== tagName =====

will keep tags with specified node, works as HTMLFilter tagName<br>
When using a list of unknowntag (as attribute in the HTMLGetter) then it is not always working exactly as HTMLFiler, sometimes it is better to us an HTMLFilter.


===== text =====

will get the text using org.htmlparser.Node.toPlainTextString()

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*example*

we start with following input, stored in  /Users/Johan/temp/temp.txt :

{{{
 <TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

to which we apply following instructionlist : 

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>  
}}}

resulting in two Strings : 

{{{
String 0, length = 1
 
String 1, length = 83

  
   Item
   Hoeveel
   Eenheid

   kcal
   Eiwit (g)
   koolh (g)
   vet (g)
}}}

The method toPlainTextString will work here on two Nodes. The first node being a text node which is appearing on top of the input, before the TBODY tag, namely there's one blank before the TBODY opening tag, which has length 1. Then a TBODY node, of which all text is taken, inclusive carriage returns.

==== processString ====

To do stuff with strings. Usually that will be the last list of instructions and will take a list of strings as input. That list of strings is the output of the last html- or XML- Filter or Getter.<br>
For some of the string processors, I've been using a package called com.Ostermiller.util, class StringHelper.<br>

A string processor can never be the first instruction in an instructionList. In case you want to use non-HTML or XML as input to a the list of instructions, start with the instruction "getUnFilteredContent"
 

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following StringProcessor :
 * append
 * containsAny
 * endsWithAny
 * equalsAny
 * escapeHTML
 * findAndReplace
 * html2text
 * idSelector
 * midPad
 * postPad
 * prepend
 * prePad
 * readDateAndTime
 * removeInvisibleChars
 * repeat
 * split
 * startsWithAny
 * trim
 * unescapeHTML

*text field*
 none
  
===== append =====

appends a string to each string in the input 

*Attributes*
 none 

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the string to append, untrimmed
  
*example*

{{{
<getContentItemList>
...
         <processString>
            <append><![CDATA[piece of text to append to each string]]></append>
         </processString>
...         
</getContentItemList>
}}}

===== containsAny =====

Filters on nodes that have text that contains any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method containsAnyIgnoreCase and containsAny 

*Attributes*
 * case_sensitive, values true or false, default true
 * include, values true or false, default false
 

*Occurrence*
 not defined

*Allowed Children*
 one or more string

*text field*
 none
  
*example*
As input for an example we can start with a small piece of HTML

{{{
<TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

Now we first apply a tagName Filter for tag "TD" :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <tagName>
                TD
            </tagName>
         </htmlFilter>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is a list of 7 Strings :
{{{
7 matching lines
Result 0, length = 42
<TD width="40%"><strong>Item</strong></TD>
Result 1, length = 45
<TD width="10%"><strong>Hoeveel</strong></TD>
Result 2, length = 45
<TD width="10%"><strong>Eenheid</strong></TD>
Result 3, length = 57
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
Result 4, length = 62
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
Result 5, length = 62
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
Result 6, length = 60
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

Now we extend the instructionlist with a containsAny string processor, with two strings, "ei" and "cal", not case_sensitive :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <tagName>
                TD
            </tagName>
         </htmlFilter>
         <processString>
           <containsAny case_sensitive="false" include="true">
			  <string>ei</string>
			  <string>Cal</string>
		   </containsAny>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

resulting in : 

3 matching lines
{{{
<TD width="10%"><strong>Eenheid</strong></TD>
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
}}}

The processor checks the complete String. I might as well define a search string "width" which would return all 7 strings.

===== equalsAny =====

Filters on nodes that have text that equals any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method equalsAnyIgnoreCase and equalsAny 

see also the string processor "containsAny"


===== endsWithAny =====

Filters on nodes that have text that ends with any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method endsWithAnyIgnoreCase and endsWithAny 

see also the string processor "containsAny"


===== escapeHTML =====

escapes HTML<br>
Using com.Ostermiller.util, class StringHelper, method escameHTML.

This will normally not be used as the goal of this package is to retrieve content from HTML (and XML) pages, not the other way around.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*
Let's start with following input :

{{{
This is a less than sign : <
}}}

Now we apply following instructionlist :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <escapeHTML>
            </escapeHTML>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is :
{{{
This is a less than sign : &lt;
}}}

===== findAndReplace =====

to find and replace a string<br>
Using com.Ostermiller.util, class StringHelper, method replace.<br>
In the find and replace elements (children of findAndReplace) it is possible to define specific invisible characters with "\t", "\b","\n","\r","\f". 

*Attributes*
 case sensitive, value "true" or "false"

*Occurrence*
 not defined

*Allowed Children*
 * find
 * replace

*text field*
 none
  
*example*
Let's start an instructionlist that fetches a list of TV programs :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://www.belgids.be/television]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de programa's op]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <and>
               <hasChild>
                  <hasChild>
                     <hasChild>
                        <stringFilter case_sensitive="false">
                           <pattern case_sensitive="false"><![CDATA[Time]]></pattern>
                        </stringFilter>
                     </hasChild>
                  </hasChild>
               </hasChild>
               <and>
                  <tagName>
                     <![CDATA[table]]>
                  </tagName>
                  <hasAttribute>
                     <attributename>
                        <![CDATA[border]]>
                     </attributename>
                     <attributevalue>
                        <![CDATA[0]]>
                     </attributevalue>
                  </hasAttribute>
               </and>
            </and> 
            <hasAttribute>
               <attributename>
                  <![CDATA[width]]>
               </attributename>
               <attributevalue>
                  <![CDATA[60%]]>
               </attributevalue>
            </hasAttribute>
         </htmlFilter>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
         <processString>
            <trim>
            </trim>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>}}}
}}}

This may result in a list of tv programs, but unfortunately it may contains some unreadable characters, like for example :<br> 
{{{
Kookstrijders BelgiÃ«-Nederland:
}}}

So we can add a find and replace instruction which will replace Ã« into ë

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://www.belgids.be/television]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de programa's op]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <and>
               <hasChild>
                  <hasChild>
                     <hasChild>
                        <stringFilter case_sensitive="false">
                           <pattern case_sensitive="false"><![CDATA[Time]]></pattern>
                        </stringFilter>
                     </hasChild>
                  </hasChild>
               </hasChild>
               <and>
                  <tagName>
                     <![CDATA[table]]>
                  </tagName>
                  <hasAttribute>
                     <attributename>
                        <![CDATA[border]]>
                     </attributename>
                     <attributevalue>
                        <![CDATA[0]]>
                     </attributevalue>
                  </hasAttribute>
               </and>
            </and> 
            <hasAttribute>
               <attributename>
                  <![CDATA[width]]>
               </attributename>
               <attributevalue>
                  <![CDATA[60%]]>
               </attributevalue>
            </hasAttribute>
         </htmlFilter>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
         <processString>
            <trim>
            </trim>
            <findAndReplace>
                <find>Ã«</find>
                <replace>ë</replace>
            </findAndReplace>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>}}}
}}}

Now we get a nicer result , here's the result (I didn't add the full list of tv programs, only the one whic contained the dirty character :

{{{
...
Kookstrijders België-Nederland:
...
}}}

===== html2text : remove everything between < and > =====

removes everything between < and ><br>

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

with following input stored in /Users/Johan/temp/temp.txt

{{{
<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.3648"><strong>Current Annual Report</strong></a>
<br>The Annual Report and Account examines the performance of the Museum over the financial year through the auditor&#8217;s report, visitor figures, costs, government funding and information on assets. The report also includes information on internal structure and management as well as plans for the future.</p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.5812"><strong>Current Annual Review</strong></a>
<br>The Annual Review acts as a condensed version of the Annual Report and Account, focusing on the key information related to the Museum&#8217;s performance. </p>
<h1>Plans and Governance</h1>

<p><a href="http://www.iwm.org.uk/upload/pdf/IWMCP10web2.pdf"><strong>Corporate Plan 2010 - 2011</strong></a>
<br>The Corporate Plan is the key to coordinating activities across the Museum&#8217;s branches along the same organisation-wide priorities and is the starting point for all staff forward job plans. It also serves as a benchmark to monitor the Museum&#8217;s progress against plans throughout the year and it seeks to respond to the risks and opportunities facing the Museum.</p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.3978"><strong>Current Funding Agreement</strong></a></p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.4621"><strong>Corporate Governance Code</strong></a></p>
}}}

with following instructionlist :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <html2text>
            </html2text>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is 14 Strings :

{{{
Current Annual Report
The Annual Report and Account examines the performance of the Museum over the financial year through the auditor&#8217;s report, visitor figures, costs, government funding and information on assets. The report also includes information on internal structure and management as well as plans for the future.

Current Annual Review
The Annual Review acts as a condensed version of the Annual Report and Account, focusing on the key information related to the Museum&#8217;s performance. 
Plans and Governance

Corporate Plan 2010 - 2011
The Corporate Plan is the key to coordinating activities across the Museum&#8217;s branches along the same organisation-wide priorities and is the starting point for all staff forward job plans. It also serves as a benchmark to monitor the Museum&#8217;s progress against plans throughout the year and it seeks to respond to the risks and opportunities facing the Museum.

Current Funding Agreement

Corporate Governance Code
}}}

===== idSelector : include or exclude specific elements identified by id =====

It is possible to specify the number of an element, to be included or excluded.
The first element has id 1, the second element has id 2 ... , but it is also possible
to identify the last element which has id 0, the last but one element has id -1<br>
More than one element can be specified or a range of elements.

*Attributes*
 include, possible values "true" or "false", default value "true"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the id's, see example
  
*example*

Let us take following input


{{{
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

we first push it through a getUnFilteredContent instruction which will give 4 strings. Then we can select for example the first line by adding an idSelector

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <idSelector include="true">
            1
            </idSelector>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

This gives us the first line as result

{{{
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
}}}

we can also define include="false", which will exclude the first line

{{{
...
            <idSelector include="false">
            1
            </idSelector>
...
}}}

resulting in

{{{
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

or define a range


{{{
...
            <idSelector include="false">
            1:3
            </idSelector>
...
}}}

resulting in

{{{
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
}}}

or identify for example the last but one element, and include only that row 

{{{
...
            <idSelector include="true">
            -1
            </idSelector>
...
}}}

resulting in :

{{{
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
}}}

or this time we exclude two specific lines :

{{{
...
            <idSelector include="false">
            1,3
            </idSelector>
...
}}}

resulting in  

{{{
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

===== midPad : pad beginning and end =====

Pad the beginning and end of each String with the given character until the result is the desired length. The result is that the original String is centered in the middle of the new string.<br>

If the number of characters to pad is even, then the padding will be distributed evenly between the beginning and end, otherwise, the extra character will be added to the end.

*Attributes*
 * mandatory attribute
   length : defines the minimum length that the new String should have
 * optional attribute
   character : defines the character to pad, default is one blank space

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

start with following input

{{{
this is text 1
this is a long text, it's a very long text
this is text 2
}}}

apply following instruction list :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <midPad character="+" length = "20">
            </midPad>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and this is the result : 

{{{
+++this is text 1+++
this is a long text, it's a very long text
+++this is text 2+++
}}}

===== postPad : pad end =====

Append the given character to the String until the result is the desired length. If a String is longer than the desired length, it will not be truncated, however no padding will be added.<br>


*Attributes*
 * mandatory attribute
   length : defines the minimum length that the new String should have
 * optional attribute
   character : defines the character to pad, default is one blank space

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

see midPad

===== prepend =====

prepends a string to each string in the input 

*Attributes*
 none 

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the string to prepend, untrimmed
  
*example*

{{{
<getContentItemList>
...
         <processString>
            <prepend><![CDATA[piece of text to prepend to each string]]></prepend>
         </processString>
...         
</getContentItemList>
}}}

===== prePad : pad beginning =====

Prepend the given character to the String until the result is the desired length. If a String is longer than the desired length, it will not be truncated, however no padding will be added.<br>


*Attributes*
 * mandatory attribute
   length : defines the minimum length that the new String should have
 * optional attribute
   character : defines the character to pad, default is one blank space

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

see midPad

===== readDateAndTime  =====

To parse a date and time field. Has a mandatory child element named SimpleDateFormat. This SimpleDateFormat can be created in exactly the same way as a the corresponding java object.<br>
Another child element is the optional element !TimeZone.<br>

*Attributes*
 * chronological, values true or false, default true
 * offset, default value = "", allowed values are "", year", "month", "day", "halfday", "hour"

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   SimpleDateFormat
 * optional child 
   !TimeZone

*text field*
 none
  
*examples*
 
This is the input stored in /Users/Johan/temp/temp.txt

{{{
15 februari 2010 22:03
28 oktober 2009 20:37
5 april 2009 15:47
27 december 2008 20:40
19 april 2010 10:11
17 april 2010 12:56
12 april 2010 20:05
9 april 2010 17:51
6 april 2010 10:13
27 maart 2010 22:18
14 maart 2010 21:22
1 maart 2010 11:48
19 februari 2010 14:07
14 februari 2010 23:12
14 februari 2010 13:29
13 februari 2010 18:46
13 februari 2010 18:43
31 januari 2010 16:54
25 januari 2010 21:56
17 januari 2010 21:43
13 januari 2010 17:26
6 januari 2010 21:35
4 januari 2010 19:16
6 december 2009 15:49
}}}

we apply following instructionlist, which has a String Processor called readDateAndTime with a SimpleDateFormat, with !SimpleDateFormatPattern "d MMMM y HH:mm", and a DateFormatSymbols element with Months "januari", ..."December"

{{{
<getContentItemList>
   <getContentItem id="1">
       <url><![CDATA[file://localhost/Users/Johan/temp/temp.txt]]></url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
        	<readDateAndTime>
        		<SimpleDateFormat>
    				<SimpleDateFormatPattern>d MMMM y HH:mm</SimpleDateFormatPattern>
    			  	<DateFormatSymbols>
    			      <Months>
    			      januari, 
    			      februari, 
    			      maart, 
    			      april, 
    			      mei, 
    			      juni, 
    			      juli, 
    			      augustus, 
    			      september, 
    			      oktober, 
    			      november, 
    			      december
    			      </Months>
    			   	</DateFormatSymbols>
	       		</SimpleDateFormat>
        	</readDateAndTime>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and the result is :

{{{
Mon Feb 15 22:03:00 CET 2010
Wed Oct 28 20:37:00 CET 2009
Sun Apr 05 15:47:00 CEST 2009
Sat Dec 27 20:40:00 CET 2008
Mon Apr 19 10:11:00 CEST 2010
Sat Apr 17 12:56:00 CEST 2010
Mon Apr 12 20:05:00 CEST 2010
Fri Apr 09 17:51:00 CEST 2010
Tue Apr 06 10:13:00 CEST 2010
Sat Mar 27 22:18:00 CET 2010
Sun Mar 14 21:22:00 CET 2010
Mon Mar 01 11:48:00 CET 2010
Fri Feb 19 14:07:00 CET 2010
Sun Feb 14 23:12:00 CET 2010
Sun Feb 14 13:29:00 CET 2010
Sat Feb 13 18:46:00 CET 2010
Sat Feb 13 18:43:00 CET 2010
Sun Jan 31 16:54:00 CET 2010
Mon Jan 25 21:56:00 CET 2010
Sun Jan 17 21:43:00 CET 2010
Wed Jan 13 17:26:00 CET 2010
Wed Jan 06 21:35:00 CET 2010
Mon Jan 04 19:16:00 CET 2010
Sun Dec 06 15:49:00 CET 2009
}}}

====== simpleDateFormat ======

see http://code.google.com/p/getcontents/wiki/SimpleDateFormat   
 
====== !TimeZone ======

a !TimeZone

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none
   

*text field*
 a timeZone ID

===== repeat =====

it is possible to repeat a number of stringProcessors, by adding the element "repeat" as child of the element processString.<br>
Element repeat extends processString and so can have a number of
stringProcessor children , the whole list will be repeated.<br>
Typically useful for example to process a findAndReplace processor multiple times, to replace two carriage returns by one, resulting in a list of strings where there are no more double carriage returns.

*Attributes*
 * attributes inherited from processString
 * repeat , minimum value 1, defines the number of repetitions

*Occurrence*
 not defined

*Allowed Children*
 * same as for processString

*text field*
 none
  
*example*

the following example gets text from a news site, at the end all double carriage returns are replaced by one carriage return, this is repeated 15 times.<br>
As a result, suppose the original text occurrences of 15 subsequent carriage returns, this will be replaced finally by just one carriage return.

{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="hln-fulltext">
...
      <instructionList>
         <htmlFilter recursive="true"  charset="UTF-8">
...
         </htmlFilter>
         <htmlGetter charset="UTF-8">
            <text/>
         </htmlGetter>
         <processString>
         	<unescapeHTML/><trim/>
         	<repeat repeat="15">
	         	<findAndReplace>
         		   <find>

</find>
					<replace>
</replace>
				</findAndReplace>
			</repeat>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

===== removeInvisibleChars =====

Removes redundant line feeds, spaces, ...<br>
At most two consecusive line feeds are retained.

*Attributes*
 * maxNewLines : optional, default value 2, defines the maximum number of consecutive linefeeds. If value = "0" then any newline will be replaced by " ". If value > 0, then if there's a sequence of more than "maxNewLines" newlines, then a replacement if the list of newlines will be done by just two newlines. 

*Occurrence*
 not defined

*Allowed Children*
 * none

*text field*
 none
  
*example*


===== split =====

Split each string with String.split(delimiter)<br>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * idSelector
 * string
   default value = " ", can be any String
 

*text field*
 none
  
*example*

We start with the result of previous example (readDateAndTime) which is a lilst of dates :

{{{
...
Wed Oct 28 20:37:00 CET 2009
Sun Apr 05 15:47:00 CEST 2009
Sat Dec 27 20:40:00 CET 2008
Mon Apr 19 10:11:00 CEST 2010
...
}}}

we can add a split, on " "

{{{
<getContentItemList>
...
        	<readDateAndTime>
        		<SimpleDateFormat>
    				<SimpleDateFormatPattern>d MMMM y HH:mm</SimpleDateFormatPattern>
    			  	<DateFormatSymbols>
    			      <Months>januari, februari, maart, april, mei, juni, juli, augustus, september, oktober, november,  december
    			      </Months>
    			   	</DateFormatSymbols>
	       		</SimpleDateFormat>
        	</readDateAndTime>
        	<split><string> </string></split>

...
</getContentItemList>
}}}

which results in 

{{{
...
Mon
Feb
15
22:03:00
CET
2010
Wed
Oct
...
}}}

====== idSelector ======

to filter out results based on id.
This works similarly to stringProcessor idSelector, but works on individual results of split.
Example if splitting one string results in 5 new strings, the idSelector will work on those 5 strings.

*Attributes*
 include, possible values "true" or "false", default value "true"

*Occurrence*
 0 or 1

*Allowed Children*
 none

*text field*
 the id's, see example
    
*example*

For more examples, see the stringProcessor instruction idSelector

We will use an idSelector to get only the first result of each split instruction in the previous example :

{{{
<getContentItemList>
...
        	<readDateAndTime>
        		<SimpleDateFormat>
    				<SimpleDateFormatPattern>d MMMM y HH:mm</SimpleDateFormatPattern>
    			  	<DateFormatSymbols>
    			      <Months>januari, februari, maart, april, mei, juni, juli, augustus, september, oktober, november,  december
    			      </Months>
    			   	</DateFormatSymbols>
	       		</SimpleDateFormat>
        	</readDateAndTime>
        	<split>
                    <string> </string>
                    <idSelector include="true">
                       1
                    </idSelector>
                </split>
...
</getContentItemList>
}}}

resulting in

{{{
Mon
Wed
Sun
Sat
Mon
Sat
Mon
Fri
Tue
Sat
Sun
Mon
Fri
Sun
Sun
Sat
Sat
Sun
Mon
Sun
Wed
Wed
Mon
Sun
}}}

In another example we start with following input, 24 strings (being the result of another set of instructions not shown here):

{{{
...
Result 1, length = 38
28 oktober 2009 20:37
			door Steffie
Result 2, length = 38
5 april 2009 15:47
			door clouseauke
Result 3, length = 38
27 december 2008 20:40
			door Marina
Result 4, length = 39
19 april 2010 10:11
			door Dennis1978
Result 5, length = 39
17 april 2010 12:56
			door meurtelken
Result 6, length = 38
12 april 2010 20:05
			door angelique
...
}}}

now we apply the split instruction with a delimiter that will check on \r, \n or \r followed by \n, and an idSelector that will pick the first result of each split.

{{{
<getContentItemList>
...
        	<split>
                        <string><![CDATA[\r\n|\r|\n]]></string>
	        	<idSelector include="true">
	        	   1
	        	</idSelector>
        	</split>
...
</getContentItemList>
}}}

resulting in

{{{
...
15 februari 2010 22:03
28 oktober 2009 20:37
5 april 2009 15:47
27 december 2008 20:40
19 april 2010 10:11
17 april 2010 12:56
12 april 2010 20:05
9 april 2010 17:51
6 april 2010 10:13
27 maart 2010 22:18
14 maart 2010 21:22
1 maart 2010 11:48
19 februari 2010 14:07
14 februari 2010 23:12
14 februari 2010 13:29
13 februari 2010 18:46
13 februari 2010 18:43
31 januari 2010 16:54
25 januari 2010 21:56
17 januari 2010 21:43
13 januari 2010 17:26
6 januari 2010 21:35
4 januari 2010 19:16
6 december 2009 15:49
...
}}}




===== startsWithAny =====

Filters on nodes that have text that starts with any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method startsWithAnyIgnoreCase and startsWithAny 

see also the string processor "containsAny"

===== trim =====

Trims each string with String.trim()<br>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

there are already a few examples here.


===== unescapeHTML =====

Trims each string with String.trim()<br>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*
 Here a simple example with input "Fiscalité locale&nbsp;: la réformer pour plus d&#8217;équité"

Instructions :

{{{
<getContentItemList>
   <getContentItem id="1">
       <url><![CDATA[file://localhost/Users/Johan/temp/temp.txt]]></url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <unescapeHTML>
            </unescapeHTML>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

Result

Fiscalité locale : la réformer pour plus d’équité

==== XMLFilter ====

An XMLFilter instruction can have an unlimited number of XML filters.<br>

The input to the first XMLFilter instruction must be valid XML. 

The output of an XMLFilter will be an array of strings, where each string is the XML representation of a node that matches the filters.
This output can then be used again as input to either another instruction like another XMLFilter, XMLGetter or processString. 

*Attributes*
 * recursive
   Values : true or false.<br>
   If a first level node does not match a filter, and if recursive is true, then the filter will continue searching in the second level node and so on.

 * charsetname
   in case the source is a String, charsetname defines the charset to be used by String.getBytes

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following StringProcessor :
 * tagName
 * containsAny
 * endsWithAny
 * equalsAny
 * hasAttribute
 * startsWithAny

*text field*
 none


===== tagName =====

filters elements with corresponding tagname 

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the tag to filter on

*example*


===== containsAny filter on elements with text that contain any of the supplied strings =====

expects as as input XML elements, takes the text in the XML element and verifies if it contains any of the strings. 

As example check out processString - containsAny

===== endsWithAny filter on elements with text that end with any of the supplied strings =====

expects as as input XML elements, takes the text in the XML element and verifies if it ends with any of the strings. 

As example check out processString - containsAny

===== equalsAny filter on elements with text that equals any of the supplied strings  =====

expects as as input XML elements, takes the text in the XML element and verifies if it equals any of the strings. 

As example check out processString - containsAny

===== hasAttribute =====

see HTML filter 'hasAttribute'<br>
Not fully tested.<br>

===== startsWithAny : filter on elements with text that start with any of the supplied strings =====

expects as as input XML elements, takes the text in the XML element and verifies if it starts with any of the strings. 

As example check out processString - containsAny


==== XMLGetter ====

An XMLGetter instruction can have an unlimited number of XML getters.<br>

The output of an XMLGetter will be an array of strings. What each string represents depends on the type of XMLGetter. It may be the text retrieved from an XML ELement, or the XML representation of an XML ELement.
This output can then be used as input to processString, and if the output represents XML elements, it can also be the input to a new XMLFilter or XMLGetter.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following XMLGetter :
 * children
 * text
 * idSelector
 * removeNodes

*text field*
 none

===== children : if the input is XML, get the children =====

if the input is XML elements, it gets the children of each root element in the input.<br>
if the input is strings, it returns null

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

===== removeNodes =====

will remove all nodes matching the specified tag

*Attributes*
 recursive, if true will search till the end, otherwise false

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the tagname

*example*

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         ...
      </url>
...
      <instructionList>
         <XMLGetter>
            <removeNodes recursive="true">script</removeNodes>
         </XMLGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>  
}}}



===== text : get the text inside the elements =====

if the input is XML elements, it gets the text of each root element in the input.<br>
if the input is strings, it returns the input

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

===== idSelector : include or exclude specific elements =====

works as the other idSelectors (see for processString - idSelector)<br>
If the input are just strings, then the output will also be strings.<br>
If the input are strings with an XML representation of XML elements, then the output will also be XML.
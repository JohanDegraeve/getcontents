#summary Explain XML instruction file.

<font color="red">THIS PAGE IS UNDER CONSTRUCTION</font>

<wiki:toc max_depth="6" />

= Introduction =

This page explains the contents of the XML instruction file.


= getContentItemList =

This is the root element in the instruction file.

*Attributes*
 * none

*Occurrence*
 since it is the root element, one and only one

*Allowed Children*
 * mandatory Children
   * getContentItem (1, 2, ...)
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
...
</getContentItemList>
}}}

== getContentItem ==

A getContentItem defines how and where to get the contents for one specific goal.
The XML element has one attribute called "id".
For example the goal could be to get the list of news titles. The requesting application needs to know the "id" to use to find the corresponding instructions.

Another example could be to fetch a TV guide. Typically a TV guide will consist of several columns, like "Program", "Channel", "Time", .. In such a case there would be three getContentItem's, each with another "id". To avoid having to get the same source (which is typicall an HTML or XML page downloaded over the internet), in such case there would be one first getContentItem whose goal is simply to download the complete page and to store in a String object. Then the next three getContentItem's would use that String as input and get a list of Programs, Channels and Time's; that means also that the source can also be a string supplied by the application.

*Attributes*
 * mandatory attributes
   * id
     A free format text used by the application to define the getContentItem to use.

*Occurrence*
 A getContentItemList must have at least one getContentItem

*Allowed Children*
 * mandatory Children
   * description (1)
   * instructionList (1)
 * optional Children
   * url (0 or 1)

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
...
   </getContentItem>
   <getContentItem id="another free format text"> 
...
   </getContentItem>
...
</getContentItemList>
}}}

=== description ===

This is free format description. Not really used yet.

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <description>
          Android World forum
      </description>
...
   </getContentItem>
...
</getContentItemList>
}}}

=== url ===

The url where the source needs to be downloaded.
Is optional, in case not present, then application must start the instructionList with source parameter which can again be a url (anything starting with '<') or the actual source content (anything not starting with '<').

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <url>
          http://www.androidworld.nl/forum/external.php
      </url>
...
   </getContentItem>
...
</getContentItemList>
}}}


=== instructionList ===

List of instructions to be executed on the source.
Instructions take as input an array of strings. The first instruction can take a string
or a url. There are different instructions, each of them are further explained by giving examples.

*Attributes*
 * none

*Occurrence*
 at least 1

*Allowed Children*
 at least one off :
 * addXMLDeclaration
 * getUnFilteredContent
 * htmlFilter
 * htmlGetter
 * processString
 * toPlainTextString
 * XMLFilter
 * XMLGetter

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 

...
   one or more instructions
...
   </getContentItem>
...
</getContentItemList>
}}}

==== addXMLDeclaration ====

Instruction to add an XML declaration on top of the input.
This is useful between an XMLFilter and an XMLGetter. Both XMLFilter and XMLGetter require valid XML as input, but the output of an XMLFilter is typically an array of Strings, with in each String an XML representation of one single XML Element. 
The concatenation of these Strings (ie of the output of the XMLFilter) is not valid XML because it misses an XML Declaration and a root element. There's no need to add a root element because this will be detected when applying the XMLGetter and added by the XMLGetter. 
However, the XML declaration must be added by applying an addXMLdeclaration.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory Children
   * version
   * encoding

*Example*

We want to get content from following XML source :

{{{
<?xml version="1.0" encoding="iso-8859-1" ?>
<rss version="2.0"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:admin="http://webns.net/mvcb/"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<channel>
 <image>
  <title>optv.nu wat is er nu op tv</title> 
  <url>http://rss.optv.nu/logo.gif</url> 
  <link>http://www.optv.nu/</link> 
  <width>144</width> 
  <height>34</height> 
  <description>OpTv.nu nu / straks op tv</description> 
 </image>
 <title>Nu en Straks Op Tv zaterdag 17/04/2010 11:29</title>
 <item>
<title><![CDATA[NU op tv]]></title>
<pubDate>Sat, 17 Apr 2010 11:29:04 +0200</pubDate>
<category>nu</category>
<description><![CDATA[the actual content has ben ommitted]]></description>
</item><item>
<title><![CDATA[STRAKS op tv]]></title>
<pubDate>Sat, 17 Apr 2010 11:29:04 +0200</pubDate>
<category>straks</category>
<description><![CDATA[the actual content has been ommitted]]></description>
</item><item><title>www.optv.nu</title><description>Deze gegevens zijn u aangeboden door http://www.optv.nu</description>
<pubDate>Sat, 17 Apr 2010 20:00:00 +0200</pubDate>
</item>
</channel>
</rss>
}}}

From this XML we want to get all titles, ie the text within elements with tag "title".

Here's the XML instruction file to start with : 

{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://rss.optv.nu/tvnustraks2.php]]>
      </url>
      <description>
         <![CDATA[blablabla]]>
      </description>
      <instructionList>
     	<XMLFilter recursive="true">
      		<tagName>
      			title
      		</tagName>
      	</XMLFilter>
       </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and the result would be :

{{{
<title><![CDATA[optv.nu wat is er nu op tv]]></title>
<title><![CDATA[Nu en Straks Op Tv zaterdag 17/04/2010 11:30]]></title>
<title><![CDATA[NU op tv]]></title>
<title><![CDATA[STRAKS op tv]]></title>
<title><![CDATA[www.optv.nu]]></title>
}}}

Now we only want to text in those elements, for which we need to use an XMLGetter instruction. But an XMLGetter requires valid XML as input. So we need to add an XML declaration, then we can apply the XMLGetter. The root element will be added by the XMLGetter.

So here's the extended instruction file that will get us all the titles :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://rss.optv.nu/tvnustraks2.php]]>
      </url>
      <description>
         <![CDATA[blablabla]]>
      </description>
      <instructionList>
         <XMLFilter recursive="true" charsetname="ISO-8859-1">
            <tagName>
               <![CDATA[title]]>
            </tagName>
         </XMLFilter>
         <addXMLDeclaration>
            <version>
               <![CDATA[1.0]]>
            </version>
            <encoding>
               <![CDATA[iso-8859-1]]>
            </encoding>
         </addXMLDeclaration>
         <XMLGetter charsetname="ISO-8859-1">
            <text>
            </text>
         </XMLGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and now the result is 

optv.nu wat is er nu op tv<br>
Nu en Straks Op Tv zaterdag 17/04/2010 11:35<br>
NU op tv<br>
STRAKS op tv<br>
www.optv.nu<br>

===== version =====

version

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none

===== encoding =====

encoding

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none

*example*
{{{
         <addXMLDeclaration>
            <version>
               <![CDATA[1.0]]>
            </version>
            <encoding>
               <![CDATA[iso-8859-1]]>
            </encoding>
         </addXMLDeclaration>
}}}

==== getUnFilteredContent ====

If the input is a URL (not starting with '<'), it will fetch the content.
If the input is not a URL, it returns the input.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

==== htmlFilter ====

An htmlFilter instruction can have an unlimited number of html filters. For filtering, the package <a href="http://htmlparser.sourceforge.net/">HTML Parser</a> is used.

The input to the htmlFilter instruction doesn't need to be a full HTML page that includes a body, head tag and so on. So you could have the output of one htmlFilter instruction, use that as input for example to a processString instruction, and use the output of that instruction again as input for a new htmlFilter instruction.

The output of an htmlFilter will be an array of strings, where each string is the result of applying toHTML on each Node (as defined in the HTML Parser package).<br>
This output can then be used again as input to either another instruction like htmlFilter, htmlGetter, processString (it is unlikely that the output of an htmlFilter will be the  input to an XMLFilter or XMLGetter).

*Attributes*
 * recursive
   Values : true or false.<br>
   If a first level node does not match a filter, and if recursive is true, then the filter will continue searching in the second level node and so on.

*Occurrence*
 not defined

*Allowed Children*
 At least one child of the following list :
 * and
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter
 * tagName

===== and =====

An AndFilter has at least two other html filters as child.<br>
Nodes that match every filer match the and filter.


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 At least two other html filters :
 * and
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" and an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
            <and>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
            </and> 
         </htmlFilter>
...
</getContentItemList>
}}}

===== cssSelectorNode =====

a CssSelectorNodeFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
none
*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the Selector

*Example*<br>


===== hasAttribute =====

a HasAttributeFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*

*Occurrence*
 none

*Allowed Children*
 * attributename
 * attributevalue

*text field*
 none

*Example*<br>
In this example we filter on nodes that have an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasChild =====

a HasChildFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

Filters on nodes that have a child that matches another included filter

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a child node that has an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
           <hasChild>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
           </hasChild>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasParent =====

a HasParentFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

Filters on nodes that have a parent node that matches another included filter

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a parent node that has an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
           <hasParent>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
           </hasParent>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasSibling =====

a HasSiblingFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none


===== linkRegexFilter =====

a LinkRegexFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   pattern

*text field*
 none

====== pattern ======

a pattern being a string and a case_sensitive attribute.
The pattern needs to compile with 
Pattern.compile(pattern,  case_sensitive == true ? 0: Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE));

*Attributes*
 case_sensitive true or false, default value = true

*Occurrence*
 1

*Allowed Children*
 none

*text field*
 the pattern string


===== linkStringFilter =====

a LinkStringFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 case_sensitive, value "true" or "false"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the pattern is defined by the textfield. The text field is stored untrimmed, that means for example inclusive carriage returns, ...


===== not =====

a NotFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 any HTML filter, only one

*text field*
 none

*example*
Filters nodes that do not have text matching the regular expression
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
            <not>
		<regexFilter>([01][0-9]|2[0-3]):[0-5][0-9]</regexFilter>
             </not>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== or =====

an OrFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 any HTML filter, at least two

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" or an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
            <or>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
            </or> 
         </htmlFilter>
...
</getContentItemList>
}}}

===== regexFilter =====

a RegexFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 strategy : possible values are "find", "lookingat" or "match"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the pattern, untrimmed

*Example*<br>
In this example we filter on nodes that have text with a time in the format HH:mm
{{{
<getContentItemList>
...
        <htmlFilter recursive="true">
            <regexFilter>([01][0-9]|2[0-3]):[0-5][0-9]</regexFilter>
         </htmlFilter>
...
</getContentItemList>
}}} 


===== stringFilter =====

a StringFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory children
   pattern

*text field*
 none


===== tagName =====

a TagNameFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the tag name

*Example*<br>
In this example we filter on nodes that have a tagname "DIV"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
               <tagName>
                  DIV
               </tagName>
         </htmlFilter>
...
</getContentItemList>
}}}


==== htmlGetter ====

a bit like a filter but applies to one specific node identified by an index ranging from 0...


*Attributes*
 recursive with value true or false. If recursive and if one specific node returns no NodeList then dig deeper into that node

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following HTMLGetter :
 * children
 * text

*text field*
 none

===== children =====

will get the children

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*example*
Let's assume we have following HTML as input, stored in /Users/Johan/temp/temp.txt

{{{
<TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

Now we run following instruction file :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example htmlGetter - children]]>
      </description>
      <instructionList>
         <htmlGetter>
            <children>
            </children>
         </htmlGetter>   
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is 

{{{
<TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
}}}


we can go one step further with the instructin file :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de zenders op]]>
      </description>
      <instructionList>
         <htmlGetter>
            <children>
            </children>
            <children>
            </children>
         </htmlGetter>   
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

now the result is (I must admit that I removed a lot of blank lines, I'm sure there will be other instructions to remove the blank lines like String Processors : 
{{{
<TD width="40%"><strong>Item</strong></TD>
<TD width="10%"><strong>Hoeveel</strong></TD>   
<TD width="10%"><strong>Eenheid</strong></TD>   
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>   
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>   
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>   
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}
  

===== text =====

will get the text using org.htmlparser.Node.toPlainTextString()

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*example*

we start with following input, stored in  /Users/Johan/temp/temp.txt :

{{{
 <TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

to which we apply following instructionlist : 

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>  
}}}

resulting in two Strings : 

{{{
String 0, length = 1
 
String 1, length = 83

  
   Item
   Hoeveel
   Eenheid

   kcal
   Eiwit (g)
   koolh (g)
   vet (g)
}}}

The method toPlainTextString will work here on two Nodes. The first node being a text node which is appearing on top of the input, before the TBODY tag, namely there's one blank before the TBODY opening tag, which has length 1. Then a TBODY node, of which all text is taken, inclusive carriage returns.

==== processString ====

To do stuff with strings. Usually that will be the last list of instructions and will take a list of strings as input. That list of strings is the output of the last html- or XML- Filter or Getter.<br>
For most of the string processors, I've been using a package called com.Ostermiller.util, class StringHelper.<br>

A string processor can never be the first instruction in an instructionList. In case you want to use non-HTML or XML as input to a the list of instructions, start with the instruction "getUnFilteredContent"
 

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following StringProcessor :
 * containsAny
 * endsWithAny
 * equalsAny
 * escapeHTML
 * findAndReplace
 * html2text
 * idSelector
 * midPad
 * postPad
 * prePad
 * readDateAndTime
 * split
 * startsWithAny
 * trim
 * unescapeHTML

*text field*
 none
  
===== containsAny =====

Filters on nodes that have text that contains any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method containsAnyIgnoreCase and containsAny 

*Attributes*
 * case_sensitive, values true or false, default true
 * include, values true or false, default false
 

*Occurrence*
 not defined

*Allowed Children*
 one or more string

*text field*
 none
  
*example*
As input for an example we can start with a small piece of HTML

{{{
<TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

Now we first apply a tagName Filter for tag "TD" :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <tagName>
                TD
            </tagName>
         </htmlFilter>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is a list of 7 Strings :
{{{
7 matching lines
Result 0, length = 42
<TD width="40%"><strong>Item</strong></TD>
Result 1, length = 45
<TD width="10%"><strong>Hoeveel</strong></TD>
Result 2, length = 45
<TD width="10%"><strong>Eenheid</strong></TD>
Result 3, length = 57
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
Result 4, length = 62
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
Result 5, length = 62
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
Result 6, length = 60
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

Now we extend the instructionlist with a containsAny string processor, with two strings, "ei" and "cal", not case_sensitive :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <tagName>
                TD
            </tagName>
         </htmlFilter>
         <processString>
           <containsAny case_sensitive="false" include="true">
			  <string>ei</string>
			  <string>Cal</string>
		   </containsAny>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

resulting in : 

3 matching lines
{{{
<TD width="10%"><strong>Eenheid</strong></TD>
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
}}}

The processor checks the complete String. I might as well define a search string "width" which would return all 7 strings.

===== endsWithAny =====

Filters on nodes that have text that ends with any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method endsWithAnyIgnoreCase and endsWithAny 

see also the string processor "containsAny"

===== escapeHTML =====

escapes HTML<br>
Using com.Ostermiller.util, class StringHelper, method escameHTML.

This will normally not be used as the goal of this package is to retrieve content from HTML (and XML) pages, not the other way around.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*
Let's start with following input :

{{{
This is a less than sign : <
}}}

Now we apply following instructionlist :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <escapeHTML>
            </escapeHTML>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is :
{{{
This is a less than sign : &lt;
}}}

===== findAndReplace =====

to find and replace a string<br>
Using com.Ostermiller.util, class StringHelper, method replace.

*Attributes*
 case sensitive, value "true" or "false"

*Occurrence*
 not defined

*Allowed Children*
 * find
 * replace

*text field*
 none
  
*example*
Let's start an instructionlist that fetches a list of TV programs :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://www.belgids.be/television]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de programa's op]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <and>
               <hasChild>
                  <hasChild>
                     <hasChild>
                        <stringFilter case_sensitive="false">
                           <pattern case_sensitive="false"><![CDATA[Time]]></pattern>
                        </stringFilter>
                     </hasChild>
                  </hasChild>
               </hasChild>
               <and>
                  <tagName>
                     <![CDATA[table]]>
                  </tagName>
                  <hasAttribute>
                     <attributename>
                        <![CDATA[border]]>
                     </attributename>
                     <attributevalue>
                        <![CDATA[0]]>
                     </attributevalue>
                  </hasAttribute>
               </and>
            </and> 
            <hasAttribute>
               <attributename>
                  <![CDATA[width]]>
               </attributename>
               <attributevalue>
                  <![CDATA[60%]]>
               </attributevalue>
            </hasAttribute>
         </htmlFilter>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
         <processString>
            <trim>
            </trim>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>}}}
}}}

This may result in a list of tv programs, but unfortunately it may contains some unreadable characters, like for example :<br> 
{{{
Kookstrijders BelgiÃ«-Nederland:
}}}

So we can add a find and replace instruction which will replace Ã« into ë

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://www.belgids.be/television]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de programa's op]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <and>
               <hasChild>
                  <hasChild>
                     <hasChild>
                        <stringFilter case_sensitive="false">
                           <pattern case_sensitive="false"><![CDATA[Time]]></pattern>
                        </stringFilter>
                     </hasChild>
                  </hasChild>
               </hasChild>
               <and>
                  <tagName>
                     <![CDATA[table]]>
                  </tagName>
                  <hasAttribute>
                     <attributename>
                        <![CDATA[border]]>
                     </attributename>
                     <attributevalue>
                        <![CDATA[0]]>
                     </attributevalue>
                  </hasAttribute>
               </and>
            </and> 
            <hasAttribute>
               <attributename>
                  <![CDATA[width]]>
               </attributename>
               <attributevalue>
                  <![CDATA[60%]]>
               </attributevalue>
            </hasAttribute>
         </htmlFilter>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
         <processString>
            <trim>
            </trim>
            <findAndReplace>
                <find>Ã«</find>
                <replace>ë</replace>
            </findAndReplace>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>}}}
}}}

Now we get a nicer result , here's the result (I didn't add the full list of tv programs, only the one whic contained the dirty character :

{{{
...
Kookstrijders België-Nederland:
...
}}}

===== html2text : remove everything between < and > =====

removes everything between < and ><br>

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

with following input stored in /Users/Johan/temp/temp.txt

{{{
<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.3648"><strong>Current Annual Report</strong></a>
<br>The Annual Report and Account examines the performance of the Museum over the financial year through the auditor&#8217;s report, visitor figures, costs, government funding and information on assets. The report also includes information on internal structure and management as well as plans for the future.</p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.5812"><strong>Current Annual Review</strong></a>
<br>The Annual Review acts as a condensed version of the Annual Report and Account, focusing on the key information related to the Museum&#8217;s performance. </p>
<h1>Plans and Governance</h1>

<p><a href="http://www.iwm.org.uk/upload/pdf/IWMCP10web2.pdf"><strong>Corporate Plan 2010 - 2011</strong></a>
<br>The Corporate Plan is the key to coordinating activities across the Museum&#8217;s branches along the same organisation-wide priorities and is the starting point for all staff forward job plans. It also serves as a benchmark to monitor the Museum&#8217;s progress against plans throughout the year and it seeks to respond to the risks and opportunities facing the Museum.</p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.3978"><strong>Current Funding Agreement</strong></a></p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.4621"><strong>Corporate Governance Code</strong></a></p>
}}}

with following instructionlist :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file:/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <html2text>
            </html2text>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is 14 Strings :

{{{
Current Annual Report
The Annual Report and Account examines the performance of the Museum over the financial year through the auditor&#8217;s report, visitor figures, costs, government funding and information on assets. The report also includes information on internal structure and management as well as plans for the future.

Current Annual Review
The Annual Review acts as a condensed version of the Annual Report and Account, focusing on the key information related to the Museum&#8217;s performance. 
Plans and Governance

Corporate Plan 2010 - 2011
The Corporate Plan is the key to coordinating activities across the Museum&#8217;s branches along the same organisation-wide priorities and is the starting point for all staff forward job plans. It also serves as a benchmark to monitor the Museum&#8217;s progress against plans throughout the year and it seeks to respond to the risks and opportunities facing the Museum.

Current Funding Agreement

Corporate Governance Code
}}}



===== startsWithAny =====

Filters on nodes that have text that starts with any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method startsWithAnyIgnoreCase and startsWithAny 

see also the string processor "containsAny"
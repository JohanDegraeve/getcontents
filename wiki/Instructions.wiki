#summary Explain XML instruction file.

<font color="red">THIS PAGE IS UNDER CONSTRUCTION</font>

<wiki:toc max_depth="6" />

= Introduction =

This page explains the contents of the XML instruction file.


= getContentItemList =

This is the root element in the instruction file.

*Attributes*
 * none

*Occurrence*
 since it is the root element, one and only one

*Allowed Children*
 * mandatory Children
   * getContentItem (1, 2, ...)
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
...
</getContentItemList>
}}}

== getContentItem ==

A getContentItem defines how and where to get the contents for one specific goal.
The XML element has one attribute called "id".
For example the goal could be to get the list of news titles. The requesting application needs to know the "id" to use to find the corresponding instructions.

Another example could be to fetch a TV guide. Typically a TV guide will consist of several columns, like "Program", "Channel", "Time", .. In such a case there would be three getContentItem's, each with another "id". To avoid having to get the same source (which is typicall an HTML or XML page downloaded over the internet), in such case there would be one first getContentItem whose goal is simply to download the complete page and to store in a String object. Then the next three getContentItem's would use that String as input and get a list of Programs, Channels and Time's; that means also that the source can also be a string supplied by the application.

*Attributes*
 * mandatory attributes
   * id
     A free format text used by the application to define the getContentItem to use.

*Occurrence*
 A getContentItemList must have at least one getContentItem

*Allowed Children*
 * mandatory Children
   * description (1)
   * instructionList (1)
 * optional Children
   * url (0 or 1)

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
...
   </getContentItem>
   <getContentItem id="another free format text"> 
...
   </getContentItem>
...
</getContentItemList>
}}}

=== description ===

This is free format description. Not really used yet.

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <description>
          Android World forum
      </description>
...
   </getContentItem>
...
</getContentItemList>
}}}

=== url ===

The url where the source needs to be downloaded.<br>
Can also be a local file.<br>
Format for a remote url : http://...<br>
Format for a local file : file://localhost/....<br>

Is optional, in case not present, then application must start the instructionList with source parameter which can again be a url (anything starting with '<') or the actual source content (anything not starting with '<').

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none

*Example*

a remote url
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <url>
          http://www.androidworld.nl/forum/external.php
      </url>
...
   </getContentItem>
...
</getContentItemList>
}}}


a local file
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <url>
          file://localhost/Users/Johan/temp/test.html
      </url>
...
   </getContentItem>
...
</getContentItemList>
}}}


=== instructionList ===

List of instructions to be executed on the source.
Instructions take as input an array of strings. The first instruction can take a string
or a url. There are different instructions, each of them are further explained by giving examples.

*Attributes*
 * none

*Occurrence*
 at least 1

*Allowed Children*
 at least one off :
 * addXMLDeclaration
 * getUnFilteredContent
 * htmlFilter
 * htmlGetter
 * processString
 * toPlainTextString
 * XMLFilter
 * XMLGetter

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 

...
   one or more instructions
...
   </getContentItem>
...
</getContentItemList>
}}}

==== addXMLDeclaration ====

Instruction to add an XML declaration on top of the input.
This is useful between an XMLFilter and an XMLGetter. Both XMLFilter and XMLGetter require valid XML as input, but the output of an XMLFilter is typically an array of Strings, with in each String an XML representation of one single XML Element. 
The concatenation of these Strings (ie of the output of the XMLFilter) is not valid XML because it misses an XML Declaration and a root element. There's no need to add a root element because this will be detected when applying the XMLGetter and added by the XMLGetter. 
However, the XML declaration must be added by applying an addXMLdeclaration.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory Children
   * version
   * encoding

*Example*

We want to get content from following XML source :

{{{
<?xml version="1.0" encoding="iso-8859-1" ?>
<rss version="2.0"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:admin="http://webns.net/mvcb/"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<channel>
 <image>
  <title>optv.nu wat is er nu op tv</title> 
  <url>http://rss.optv.nu/logo.gif</url> 
  <link>http://www.optv.nu/</link> 
  <width>144</width> 
  <height>34</height> 
  <description>OpTv.nu nu / straks op tv</description> 
 </image>
 <title>Nu en Straks Op Tv zaterdag 17/04/2010 11:29</title>
 <item>
<title><![CDATA[NU op tv]]></title>
<pubDate>Sat, 17 Apr 2010 11:29:04 +0200</pubDate>
<category>nu</category>
<description><![CDATA[the actual content has ben ommitted]]></description>
</item><item>
<title><![CDATA[STRAKS op tv]]></title>
<pubDate>Sat, 17 Apr 2010 11:29:04 +0200</pubDate>
<category>straks</category>
<description><![CDATA[the actual content has been ommitted]]></description>
</item><item><title>www.optv.nu</title><description>Deze gegevens zijn u aangeboden door http://www.optv.nu</description>
<pubDate>Sat, 17 Apr 2010 20:00:00 +0200</pubDate>
</item>
</channel>
</rss>
}}}

From this XML we want to get all titles, ie the text within elements with tag "title".

Here's the XML instruction file to start with : 

{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://rss.optv.nu/tvnustraks2.php]]>
      </url>
      <description>
         <![CDATA[blablabla]]>
      </description>
      <instructionList>
     	<XMLFilter recursive="true">
      		<tagName>
      			title
      		</tagName>
      	</XMLFilter>
       </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and the result would be :

{{{
<title><![CDATA[optv.nu wat is er nu op tv]]></title>
<title><![CDATA[Nu en Straks Op Tv zaterdag 17/04/2010 11:30]]></title>
<title><![CDATA[NU op tv]]></title>
<title><![CDATA[STRAKS op tv]]></title>
<title><![CDATA[www.optv.nu]]></title>
}}}

Now we only want to text in those elements, for which we need to use an XMLGetter instruction. But an XMLGetter requires valid XML as input. So we need to add an XML declaration, then we can apply the XMLGetter. The root element will be added by the XMLGetter.

So here's the extended instruction file that will get us all the titles :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://rss.optv.nu/tvnustraks2.php]]>
      </url>
      <description>
         <![CDATA[blablabla]]>
      </description>
      <instructionList>
         <XMLFilter recursive="true" charsetname="ISO-8859-1">
            <tagName>
               <![CDATA[title]]>
            </tagName>
         </XMLFilter>
         <addXMLDeclaration>
            <version>
               <![CDATA[1.0]]>
            </version>
            <encoding>
               <![CDATA[iso-8859-1]]>
            </encoding>
         </addXMLDeclaration>
         <XMLGetter charsetname="ISO-8859-1">
            <text>
            </text>
         </XMLGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and now the result is 

optv.nu wat is er nu op tv<br>
Nu en Straks Op Tv zaterdag 17/04/2010 11:35<br>
NU op tv<br>
STRAKS op tv<br>
www.optv.nu<br>

===== version =====

version

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none

===== encoding =====

encoding

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none

*example*
{{{
         <addXMLDeclaration>
            <version>
               <![CDATA[1.0]]>
            </version>
            <encoding>
               <![CDATA[iso-8859-1]]>
            </encoding>
         </addXMLDeclaration>
}}}

==== getUnFilteredContent ====

If the input is a URL (anything not starting with '<'), it will fetch the content.
If the input is not a URL, it returns the input.<br>
So it is important, if the input is to be seen as a source text (ie not a URL), then the first non blank character should be a '<'.<br>

The instruction will read line by line in the source, each line results in a string in an array that will be the result of this instruction. So the result of this instruction will be an array of String.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

==== htmlFilter ====

An htmlFilter instruction can have an unlimited number of html filters. For filtering, the package <a href="http://htmlparser.sourceforge.net/">HTML Parser</a> is used.

The input to the htmlFilter instruction doesn't need to be a full HTML page that includes a body, head tag and so on. So you could have the output of one htmlFilter instruction, use that as input for example to a processString instruction, and use the output of that instruction again as input for a new htmlFilter instruction.

The output of an htmlFilter will be an array of strings, where each string is the result of applying toHTML on each Node (as defined in the HTML Parser package).<br>
This output can then be used again as input to either another instruction like htmlFilter, htmlGetter, processString (it is unlikely that the output of an htmlFilter will be the  input to an XMLFilter or XMLGetter).

*Attributes*
 * recursive
   Values : true or false.<br>
   If a first level node does not match a filter, and if recursive is true, then the filter will continue searching in the second level node and so on.

*Occurrence*
 not defined

*Allowed Children*
 At least one child of the following list :
 * and
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter
 * tagName

===== and =====

An AndFilter has at least two other html filters as child.<br>
Nodes that match every filer match the and filter.


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 At least two other html filters :
 * and
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" and an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
            <and>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
            </and> 
         </htmlFilter>
...
</getContentItemList>
}}}

===== cssSelectorNode =====

a CssSelectorNodeFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
none
*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the Selector

*Example*<br>


===== hasAttribute =====

a HasAttributeFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*

*Occurrence*
 none

*Allowed Children*
 * attributename
 * attributevalue

*text field*
 none

*Example*<br>
In this example we filter on nodes that have an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasChild =====

a HasChildFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

Filters on nodes that have a child that matches another included filter

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a child node that has an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
           <hasChild>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
           </hasChild>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasParent =====

a HasParentFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>

Filters on nodes that have a parent node that matches another included filter

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a parent node that has an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
           <hasParent>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
           </hasParent>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== hasSibling =====

a HasSiblingFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   any other HTML filter

*text field*
 none


===== linkRegexFilter =====

a LinkRegexFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   pattern

*text field*
 none

====== pattern ======

a pattern being a string and a case_sensitive attribute.
The pattern needs to compile with 
Pattern.compile(pattern,  case_sensitive == true ? 0: Pattern.CASE_INSENSITIVE + Pattern.UNICODE_CASE));

*Attributes*
 case_sensitive true or false, default value = true

*Occurrence*
 1

*Allowed Children*
 none

*text field*
 the pattern string


===== linkStringFilter =====

a LinkStringFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 case_sensitive, value "true" or "false"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the pattern is defined by the textfield. The text field is stored untrimmed, that means for example inclusive carriage returns, ...


===== not =====

a NotFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 any HTML filter, only one

*text field*
 none

*example*
Filters nodes that do not have text matching the regular expression
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
...
            <not>
		<regexFilter>([01][0-9]|2[0-3]):[0-5][0-9]</regexFilter>
             </not>
....
         </htmlFilter>
...
</getContentItemList>
}}}


===== or =====

an OrFilter  as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 any HTML filter, at least two

*text field*
 none

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" or an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
            <or>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
            </or> 
         </htmlFilter>
...
</getContentItemList>
}}}

===== regexFilter =====

a RegexFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 strategy : possible values are "find", "lookingat" or "match"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the pattern, untrimmed

*Example*<br>
In this example we filter on nodes that have text with a time in the format HH:mm
{{{
<getContentItemList>
...
        <htmlFilter recursive="true">
            <regexFilter>([01][0-9]|2[0-3]):[0-5][0-9]</regexFilter>
         </htmlFilter>
...
</getContentItemList>
}}} 


===== stringFilter =====

a StringFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory children
   pattern

*text field*
 none


===== tagName =====

a TagNameFilter as defined in the HTML parser package :  
<a href="http://htmlparser.sourceforge.net/">HTML Parser</a>


*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the tag name

*Example*<br>
In this example we filter on nodes that have a tagname "DIV"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
               <tagName>
                  DIV
               </tagName>
         </htmlFilter>
...
</getContentItemList>
}}}


==== htmlGetter ====

a bit like a filter but applies to one specific node identified by an index ranging from 0...


*Attributes*
 recursive with value true or false. If recursive and if one specific node returns no NodeList then dig deeper into that node

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following HTMLGetter :
 * children
 * text

*text field*
 none

===== children =====

will get the children

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*example*
Let's assume we have following HTML as input, stored in /Users/Johan/temp/temp.txt

{{{
<TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

Now we run following instruction file :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example htmlGetter - children]]>
      </description>
      <instructionList>
         <htmlGetter>
            <children>
            </children>
         </htmlGetter>   
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is 

{{{
<TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
}}}


we can go one step further with the instructin file :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de zenders op]]>
      </description>
      <instructionList>
         <htmlGetter>
            <children>
            </children>
            <children>
            </children>
         </htmlGetter>   
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

now the result is (I must admit that I removed a lot of blank lines, I'm sure there will be other instructions to remove the blank lines like String Processors : 
{{{
<TD width="40%"><strong>Item</strong></TD>
<TD width="10%"><strong>Hoeveel</strong></TD>   
<TD width="10%"><strong>Eenheid</strong></TD>   
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>   
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>   
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>   
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}
  

===== text =====

will get the text using org.htmlparser.Node.toPlainTextString()

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none

*example*

we start with following input, stored in  /Users/Johan/temp/temp.txt :

{{{
 <TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

to which we apply following instructionlist : 

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>  
}}}

resulting in two Strings : 

{{{
String 0, length = 1
 
String 1, length = 83

  
   Item
   Hoeveel
   Eenheid

   kcal
   Eiwit (g)
   koolh (g)
   vet (g)
}}}

The method toPlainTextString will work here on two Nodes. The first node being a text node which is appearing on top of the input, before the TBODY tag, namely there's one blank before the TBODY opening tag, which has length 1. Then a TBODY node, of which all text is taken, inclusive carriage returns.

==== processString ====

To do stuff with strings. Usually that will be the last list of instructions and will take a list of strings as input. That list of strings is the output of the last html- or XML- Filter or Getter.<br>
For most of the string processors, I've been using a package called com.Ostermiller.util, class StringHelper.<br>

A string processor can never be the first instruction in an instructionList. In case you want to use non-HTML or XML as input to a the list of instructions, start with the instruction "getUnFilteredContent"
 

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 One ore more of following StringProcessor :
 * containsAny
 * endsWithAny
 * equalsAny
 * escapeHTML
 * findAndReplace
 * html2text
 * idSelector
 * midPad
 * postPad
 * prePad
 * readDateAndTime
 * split
 * startsWithAny
 * trim
 * unescapeHTML

*text field*
 none
  
===== containsAny =====

Filters on nodes that have text that contains any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method containsAnyIgnoreCase and containsAny 

*Attributes*
 * case_sensitive, values true or false, default true
 * include, values true or false, default false
 

*Occurrence*
 not defined

*Allowed Children*
 one or more string

*text field*
 none
  
*example*
As input for an example we can start with a small piece of HTML

{{{
<TBODY>
  <TR bgColor=#f0f0f0>
   <TD width="40%"><strong>Item</strong></TD>
   <TD width="10%"><strong>Hoeveel</strong></TD>
   <TD width="10%"><strong>Eenheid</strong></TD>

   <TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
   <TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
   <TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
  </TR>
</TBODY>
}}}

Now we first apply a tagName Filter for tag "TD" :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <tagName>
                TD
            </tagName>
         </htmlFilter>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is a list of 7 Strings :
{{{
7 matching lines
Result 0, length = 42
<TD width="40%"><strong>Item</strong></TD>
Result 1, length = 45
<TD width="10%"><strong>Hoeveel</strong></TD>
Result 2, length = 45
<TD width="10%"><strong>Eenheid</strong></TD>
Result 3, length = 57
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
Result 4, length = 62
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
Result 5, length = 62
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
Result 6, length = 60
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

Now we extend the instructionlist with a containsAny string processor, with two strings, "ei" and "cal", not case_sensitive :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <tagName>
                TD
            </tagName>
         </htmlFilter>
         <processString>
           <containsAny case_sensitive="false" include="true">
			  <string>ei</string>
			  <string>Cal</string>
		   </containsAny>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

resulting in : 

3 matching lines
{{{
<TD width="10%"><strong>Eenheid</strong></TD>
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
}}}

The processor checks the complete String. I might as well define a search string "width" which would return all 7 strings.

===== equalsAny =====

Filters on nodes that have text that equals any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method equalsAnyIgnoreCase and equalsAny 

see also the string processor "containsAny"


===== endsWithAny =====

Filters on nodes that have text that ends with any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method endsWithAnyIgnoreCase and endsWithAny 

see also the string processor "containsAny"


===== escapeHTML =====

escapes HTML<br>
Using com.Ostermiller.util, class StringHelper, method escameHTML.

This will normally not be used as the goal of this package is to retrieve content from HTML (and XML) pages, not the other way around.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*
Let's start with following input :

{{{
This is a less than sign : <
}}}

Now we apply following instructionlist :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <escapeHTML>
            </escapeHTML>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is :
{{{
This is a less than sign : &lt;
}}}

===== findAndReplace =====

to find and replace a string<br>
Using com.Ostermiller.util, class StringHelper, method replace.

*Attributes*
 case sensitive, value "true" or "false"

*Occurrence*
 not defined

*Allowed Children*
 * find
 * replace

*text field*
 none
  
*example*
Let's start an instructionlist that fetches a list of TV programs :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://www.belgids.be/television]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de programa's op]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <and>
               <hasChild>
                  <hasChild>
                     <hasChild>
                        <stringFilter case_sensitive="false">
                           <pattern case_sensitive="false"><![CDATA[Time]]></pattern>
                        </stringFilter>
                     </hasChild>
                  </hasChild>
               </hasChild>
               <and>
                  <tagName>
                     <![CDATA[table]]>
                  </tagName>
                  <hasAttribute>
                     <attributename>
                        <![CDATA[border]]>
                     </attributename>
                     <attributevalue>
                        <![CDATA[0]]>
                     </attributevalue>
                  </hasAttribute>
               </and>
            </and> 
            <hasAttribute>
               <attributename>
                  <![CDATA[width]]>
               </attributename>
               <attributevalue>
                  <![CDATA[60%]]>
               </attributevalue>
            </hasAttribute>
         </htmlFilter>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
         <processString>
            <trim>
            </trim>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>}}}
}}}

This may result in a list of tv programs, but unfortunately it may contains some unreadable characters, like for example :<br> 
{{{
Kookstrijders BelgiÃ«-Nederland:
}}}

So we can add a find and replace instruction which will replace Ã« into ë

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://www.belgids.be/television]]>
      </url>
      <description>
         <![CDATA[Programs http://www.belgids.be/television haal de programa's op]]>
      </description>
      <instructionList>
         <htmlFilter recursive="true">
            <and>
               <hasChild>
                  <hasChild>
                     <hasChild>
                        <stringFilter case_sensitive="false">
                           <pattern case_sensitive="false"><![CDATA[Time]]></pattern>
                        </stringFilter>
                     </hasChild>
                  </hasChild>
               </hasChild>
               <and>
                  <tagName>
                     <![CDATA[table]]>
                  </tagName>
                  <hasAttribute>
                     <attributename>
                        <![CDATA[border]]>
                     </attributename>
                     <attributevalue>
                        <![CDATA[0]]>
                     </attributevalue>
                  </hasAttribute>
               </and>
            </and> 
            <hasAttribute>
               <attributename>
                  <![CDATA[width]]>
               </attributename>
               <attributevalue>
                  <![CDATA[60%]]>
               </attributevalue>
            </hasAttribute>
         </htmlFilter>
         <htmlGetter recursive="false">
            <text>
            </text>
         </htmlGetter>
         <processString>
            <trim>
            </trim>
            <findAndReplace>
                <find>Ã«</find>
                <replace>ë</replace>
            </findAndReplace>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>}}}
}}}

Now we get a nicer result , here's the result (I didn't add the full list of tv programs, only the one whic contained the dirty character :

{{{
...
Kookstrijders België-Nederland:
...
}}}

===== html2text : remove everything between < and > =====

removes everything between < and ><br>

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

with following input stored in /Users/Johan/temp/temp.txt

{{{
<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.3648"><strong>Current Annual Report</strong></a>
<br>The Annual Report and Account examines the performance of the Museum over the financial year through the auditor&#8217;s report, visitor figures, costs, government funding and information on assets. The report also includes information on internal structure and management as well as plans for the future.</p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.5812"><strong>Current Annual Review</strong></a>
<br>The Annual Review acts as a condensed version of the Annual Report and Account, focusing on the key information related to the Museum&#8217;s performance. </p>
<h1>Plans and Governance</h1>

<p><a href="http://www.iwm.org.uk/upload/pdf/IWMCP10web2.pdf"><strong>Corporate Plan 2010 - 2011</strong></a>
<br>The Corporate Plan is the key to coordinating activities across the Museum&#8217;s branches along the same organisation-wide priorities and is the starting point for all staff forward job plans. It also serves as a benchmark to monitor the Museum&#8217;s progress against plans throughout the year and it seeks to respond to the risks and opportunities facing the Museum.</p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.3978"><strong>Current Funding Agreement</strong></a></p>

<p><a href="http://www.iwm.org.uk/server/show/ConWebDoc.4621"><strong>Corporate Governance Code</strong></a></p>
}}}

with following instructionlist :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <html2text>
            </html2text>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

the result is 14 Strings :

{{{
Current Annual Report
The Annual Report and Account examines the performance of the Museum over the financial year through the auditor&#8217;s report, visitor figures, costs, government funding and information on assets. The report also includes information on internal structure and management as well as plans for the future.

Current Annual Review
The Annual Review acts as a condensed version of the Annual Report and Account, focusing on the key information related to the Museum&#8217;s performance. 
Plans and Governance

Corporate Plan 2010 - 2011
The Corporate Plan is the key to coordinating activities across the Museum&#8217;s branches along the same organisation-wide priorities and is the starting point for all staff forward job plans. It also serves as a benchmark to monitor the Museum&#8217;s progress against plans throughout the year and it seeks to respond to the risks and opportunities facing the Museum.

Current Funding Agreement

Corporate Governance Code
}}}

===== idSelector : include or exclude specific elements identified by id =====

It is possible to specify the number of an element, to be included or excluded.
The first element has id 1, the second element has id 2 ... , but it is also possible
to identify the last element which has id 0, the last but one element has id -1<br>
More than one element can be specified or a range of elements.

*Attributes*
 include, possible values "true" or "false", default value "true"

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 the id's, see example
  
*example*

Let us take following input


{{{
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

we first push it through a getUnFilteredContent instruction which will give 4 strings. Then we can select for example the first line by adding an idSelector

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <idSelector include="true">
            1
            </idSelector>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

This gives us the first line as result

{{{
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
}}}

we can also define include="false", which will exclude the first line

{{{
...
            <idSelector include="false">
            1
            </idSelector>
...
}}}

resulting in

{{{
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

or define a range


{{{
...
            <idSelector include="false">
            1:3
            </idSelector>
...
}}}

resulting in

{{{
<TD width="10%" ALIGN="center"><strong>kcal</strong></TD>
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
}}}

or identify for example the last but one element, and include only that row 

{{{
...
            <idSelector include="true">
            -1
            </idSelector>
...
}}}

resulting in :

{{{
<TD width="10%" ALIGN="center"><strong>koolh (g)</strong></TD>
}}}

or this time we exclude two specific lines :

{{{
...
            <idSelector include="false">
            1,3
            </idSelector>
...
}}}

resulting in  

{{{
<TD width="10%" ALIGN="center"><strong>Eiwit (g)</strong></TD>
<TD width="10%" ALIGN="center"><strong>vet (g)</strong></TD>
}}}

===== midPad : pad beginning and end =====

Pad the beginning and end of each String with the given character until the result is the desired length. The result is that the original String is centered in the middle of the new string.<br>

If the number of characters to pad is even, then the padding will be split evenly between the beginning and end, otherwise, the extra character will be added to the end.

*Attributes*
 * mandatory attribute
   length : defines the minimum length that the new String should have
 * optional attribute
   character : defines the character to pad, default is one blank space

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

start with following input

{{{
this is text 1
this is a long text, it's a very long text
this is text 2
}}}

apply following instruction list :

{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[file://localhost/Users/Johan/temp/temp.txt]]>
      </url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
            <midPad character="+" length = "20">
            </midPad>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and this is the result : 

{{{
+++this is text 1+++
this is a long text, it's a very long text
+++this is text 2+++
}}}

===== postPad : pad end =====

Append the given character to the String until the result is the desired length. If a String is longer than the desired length, it will not be truncated, however no padding will be added.<br>


*Attributes*
 * mandatory attribute
   length : defines the minimum length that the new String should have
 * optional attribute
   character : defines the character to pad, default is one blank space

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

see midPad

===== prePad : pad beginning =====

Prepend the given character to the String until the result is the desired length. If a String is longer than the desired length, it will not be truncated, however no padding will be added.<br>


*Attributes*
 * mandatory attribute
   length : defines the minimum length that the new String should have
 * optional attribute
   character : defines the character to pad, default is one blank space

*Occurrence*
 not defined

*Allowed Children*
 none

*text field*
 none
  
*example*

see midPad

===== readDateAndTime  =====

To parse a date and time field. Has a mandatory child element named SimpleDateFormat. This SimpleDateFormat can be created in exactly the same way as a the corresponding java object.<br>
Another child element is the optional element TimeZone.<br>

*Attributes*
 * chronological, values true or false, default true
 * offset, default value = "", allowed values are "", year", "month", "day", "halfday", "hour"

*Occurrence*
 not defined

*Allowed Children*
 * mandatory child
   SimpleDateFormat
 * optional child 
   TimeZone

*text field*
 none
  
*examples*
 
This is the input stored in /Users/Johan/temp/temp.txt

{{{
15 februari 2010 22:03
28 oktober 2009 20:37
5 april 2009 15:47
27 december 2008 20:40
19 april 2010 10:11
17 april 2010 12:56
12 april 2010 20:05
9 april 2010 17:51
6 april 2010 10:13
27 maart 2010 22:18
14 maart 2010 21:22
1 maart 2010 11:48
19 februari 2010 14:07
14 februari 2010 23:12
14 februari 2010 13:29
13 februari 2010 18:46
13 februari 2010 18:43
31 januari 2010 16:54
25 januari 2010 21:56
17 januari 2010 21:43
13 januari 2010 17:26
6 januari 2010 21:35
4 januari 2010 19:16
6 december 2009 15:49
}}}

we apply following instructionlist, which has a String Processor called readDateAndTime with a SimpleDateFormat, with simpleDateFormatPattern "d MMMM y HH:mm", and a DateFormatSymbols element with Months "januari", ..."December"

{{{
<getContentItemList>
   <getContentItem id="1">
       <url><![CDATA[file://localhost/Users/Johan/temp/temp.txt]]></url>
      <description>
         <![CDATA[example]]>
      </description>
      <instructionList>
         <getUnFilteredContent>
         </getUnFilteredContent>
         <processString>
        	<readDateAndTime>
        		<SimpleDateFormat>
    				<simpleDateFormatPattern>d MMMM y HH:mm</simpleDateFormatPattern>
    			  	<DateFormatSymbols>
    			      <Months>
    			      januari, 
    			      februari, 
    			      maart, 
    			      april, 
    			      mei, 
    			      juni, 
    			      juli, 
    			      augustus, 
    			      september, 
    			      oktober, 
    			      november, 
    			      december
    			      </Months>
    			   	</DateFormatSymbols>
	       		</SimpleDateFormat>
        	</readDateAndTime>
         </processString>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and the result is :

{{{
Mon Feb 15 22:03:00 CET 2010
Wed Oct 28 20:37:00 CET 2009
Sun Apr 05 15:47:00 CEST 2009
Sat Dec 27 20:40:00 CET 2008
Mon Apr 19 10:11:00 CEST 2010
Sat Apr 17 12:56:00 CEST 2010
Mon Apr 12 20:05:00 CEST 2010
Fri Apr 09 17:51:00 CEST 2010
Tue Apr 06 10:13:00 CEST 2010
Sat Mar 27 22:18:00 CET 2010
Sun Mar 14 21:22:00 CET 2010
Mon Mar 01 11:48:00 CET 2010
Fri Feb 19 14:07:00 CET 2010
Sun Feb 14 23:12:00 CET 2010
Sun Feb 14 13:29:00 CET 2010
Sat Feb 13 18:46:00 CET 2010
Sat Feb 13 18:43:00 CET 2010
Sun Jan 31 16:54:00 CET 2010
Mon Jan 25 21:56:00 CET 2010
Sun Jan 17 21:43:00 CET 2010
Wed Jan 13 17:26:00 CET 2010
Wed Jan 06 21:35:00 CET 2010
Mon Jan 04 19:16:00 CET 2010
Sun Dec 06 15:49:00 CET 2009
}}}


===== startsWithAny =====

Filters on nodes that have text that starts with any of a list of strings<br>
Using com.Ostermiller.util, class StringHelper, method startsWithAnyIgnoreCase and startsWithAny 

see also the string processor "containsAny"
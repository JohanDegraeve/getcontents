#summary Explain XML instruction file.

<font color="red">THIS PAGE IS UNDER CONSTRUCTION</font>

<wiki:toc max_depth="5" />

= Introduction =

This page explains the contents of the XML instruction file.


= getContentItemList =

This is the root element in the instruction file.

*Attributes*
 * none

*Occurrence*
 since it is the root element, one and only one

*Allowed Children*
 * mandatory Children
   * getContentItem (1, 2, ...)
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
...
</getContentItemList>
}}}

== getContentItem ==

A getContentItem defines how and where to get the contents for one specific goal.
The XML element has one attribute called "id".
For example the goal could be to get the list of news titles. The requesting application needs to know the "id" to use to find the corresponding instructions.

Another example could be to fetch a TV guide. Typically a TV guide will consist of several columns, like "Program", "Channel", "Time", .. In such a case there would be three getContentItem's, each with another "id". To avoid having to get the same source (which is typicall an HTML or XML page downloaded over the internet), in such case there would be one first getContentItem whose goal is simply to download the complete page and to store in a String object. Then the next three getContentItem's would use that String as input and get a list of Programs, Channels and Time's; that means also that the source can also be a string supplied by the application.

*Attributes*
 * mandatory attributes
   * id
     A free format text used by the application to define the getContentItem to use.

*Occurrence*
 A getContentItemList must have at least one getContentItem

*Allowed Children*
 * mandatory Children
   * description (1)
   * instructionList (1)
 * optional Children
   * url (0 or 1)

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
...
   </getContentItem>
   <getContentItem id="another free format text"> 
...
   </getContentItem>
...
</getContentItemList>
}}}

=== description ===

This is free format description. Not really used yet.

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none
  

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <description>
          Android World forum
      </description>
...
   </getContentItem>
...
</getContentItemList>
}}}

=== url ===

The url where the source needs to be downloaded.
Is optional, in case not present, then application must start the instructionList with source parameter which can again be a url (anything starting with '<') or the actual source content (anything not starting with '<').

*Attributes*
 * none

*Occurrence*
 none or one

*Allowed Children*
 none

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 
      <url>
          http://www.androidworld.nl/forum/external.php
      </url>
...
   </getContentItem>
...
</getContentItemList>
}}}


=== instructionList ===

List of instructions to be executed on the source.
Instructions take as input an array of strings. The first instruction can take a string
or a url. There are different instructions, each of them are further explained by giving examples.

*Attributes*
 * none

*Occurrence*
 at least 1

*Allowed Children*
 at least one off :
 * addXMLDeclaration
 * getUnFilteredContent
 * htmlFilter
 * htmlGetter
 * processString
 * toPlainTextString
 * XMLFilter
 * XMLGetter

*Example*
{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1"> 

...
   one or more instructions
...
   </getContentItem>
...
</getContentItemList>
}}}

==== addXMLDeclaration ====

Instruction to add an XML declaration on top of the input.
This is useful between an XMLFilter and an XMLGetter. Both XMLFilter and XMLGetter require valid XML as input, but the output of an XMLFilter is typically an array of Strings, with in each String an XML representation of one single XML Element. 
The concatenation of these Strings (ie of the output of the XMLFilter) is not valid XML because it misses an XML Declaration and a root element. There's no need to add a root element because this will be detected when applying the XMLGetter and added by the XMLGetter. 
However, the XML declaration must be added by applying an addXMLdeclaration.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 * Mandatory Children
   * version
   * encoding

*Example*

We want to get content from following XML source :

{{{
<?xml version="1.0" encoding="iso-8859-1" ?>
<rss version="2.0"
  xmlns:dc="http://purl.org/dc/elements/1.1/"
  xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
  xmlns:admin="http://webns.net/mvcb/"
  xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
<channel>
 <image>
  <title>optv.nu wat is er nu op tv</title> 
  <url>http://rss.optv.nu/logo.gif</url> 
  <link>http://www.optv.nu/</link> 
  <width>144</width> 
  <height>34</height> 
  <description>OpTv.nu nu / straks op tv</description> 
 </image>
 <title>Nu en Straks Op Tv zaterdag 17/04/2010 11:29</title>
 <item>
<title><![CDATA[NU op tv]]></title>
<pubDate>Sat, 17 Apr 2010 11:29:04 +0200</pubDate>
<category>nu</category>
<description><![CDATA[the actual content has ben ommitted]]></description>
</item><item>
<title><![CDATA[STRAKS op tv]]></title>
<pubDate>Sat, 17 Apr 2010 11:29:04 +0200</pubDate>
<category>straks</category>
<description><![CDATA[the actual content has been ommitted]]></description>
</item><item><title>www.optv.nu</title><description>Deze gegevens zijn u aangeboden door http://www.optv.nu</description>
<pubDate>Sat, 17 Apr 2010 20:00:00 +0200</pubDate>
</item>
</channel>
</rss>
}}}

From this XML we want to get all titles, ie the text within elements with tag "title".

Here's the XML instruction file to start with : 

{{{
<?xml version="1.0" encoding="UTF-8" ?>
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://rss.optv.nu/tvnustraks2.php]]>
      </url>
      <description>
         <![CDATA[blablabla]]>
      </description>
      <instructionList>
     	<XMLFilter recursive="true">
      		<tagName>
      			title
      		</tagName>
      	</XMLFilter>
       </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and the result would be :

{{{
<title><![CDATA[optv.nu wat is er nu op tv]]></title>
<title><![CDATA[Nu en Straks Op Tv zaterdag 17/04/2010 11:30]]></title>
<title><![CDATA[NU op tv]]></title>
<title><![CDATA[STRAKS op tv]]></title>
<title><![CDATA[www.optv.nu]]></title>
}}}

Now we only want to text in those elements, for which we need to use an XMLGetter instruction. But an XMLGetter requires valid XML as input. So we need to add an XML declaration, then we can apply the XMLGetter. The root element will be added by the XMLGetter.

So here's the extended instruction file that will get us all the titles :
{{{
<getContentItemList>
   <getContentItem id="1">
      <url>
         <![CDATA[http://rss.optv.nu/tvnustraks2.php]]>
      </url>
      <description>
         <![CDATA[blablabla]]>
      </description>
      <instructionList>
         <XMLFilter recursive="true" charsetname="ISO-8859-1">
            <tagName>
               <![CDATA[title]]>
            </tagName>
         </XMLFilter>
         <addXMLDeclaration>
            <version>
               <![CDATA[1.0]]>
            </version>
            <encoding>
               <![CDATA[iso-8859-1]]>
            </encoding>
         </addXMLDeclaration>
         <XMLGetter charsetname="ISO-8859-1">
            <text>
            </text>
         </XMLGetter>
      </instructionList>
   </getContentItem>
</getContentItemList>
}}}

and now the result is 

optv.nu wat is er nu op tv<br>
Nu en Straks Op Tv zaterdag 17/04/2010 11:35<br>
NU op tv<br>
STRAKS op tv<br>
www.optv.nu<br>

===== version =====

version

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none

===== encoding =====

encoding

*Attributes*
 none

*Occurrence*
 1

*Allowed Children*
 none

*example*
{{{
         <addXMLDeclaration>
            <version>
               <![CDATA[1.0]]>
            </version>
            <encoding>
               <![CDATA[iso-8859-1]]>
            </encoding>
         </addXMLDeclaration>
}}}

==== getUnFilteredContent ====

If the input is a URL (not starting with '<'), it will fetch the content.
If the input is not a URL, it returns the input.

*Attributes*
 none

*Occurrence*
 not defined

*Allowed Children*
 none

==== htmlFilter ====

An htmlFilter instruction can have an unlimited number of html filters. For filtering, the package <a href="http://htmlparser.sourceforge.net/">HTML Parser</a> is used.

The input to the htmlFilter instruction doesn't need to be a full HTML page. So you could have the output of one htmlFilter instruction, use that as input for example to a processString instruction, and use the output of that instruction again as input for a new htmlFilter instruction.

*Attributes*
 * recursive
   Values : true or false.<br>
   If a first level node does not match a filter, and if recursive is true, then the filter will continue searching in the second level node and so on.

*Occurrence*
 not defined

*Allowed Children*
 At least one child of the following list :
 * and
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter

===== and =====

An and Filter has at least two other html filters as child.<br>
Nodes that match every filer match the and filter.


*Attributes*
none
*Occurrence*
 not defined

*Allowed Children*
 At least two other html filters :
 * and
 * cssSelectorNode
 * hasAttribute
 * hasChild
 * hasParent
 * hasSibling
 * linkRegexFilter
 * linkStringFilter
 * not
 * or
 * regexFilter
 * stringFilter

*Example*<br>
In this example we filter on nodes that have a tagname "DIV" and an attribute border="0"
{{{
<getContentItemList>
...
         <htmlFilter recursive="true">
            <and>
               <tagName>
                  DIV
               </tagName>
               <hasAttribute>
                   <attributename>
                        <![CDATA[border]]>
                   </attributename>
                   <attributevalue>
                        <![CDATA[0]]>
                   </attributevalue>
               </hasAttribute>
             </and> 
         </htmlFilter>
...
</getContentItemList>
}}}